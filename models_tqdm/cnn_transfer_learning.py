# -*- coding: utf-8 -*-
"""CNN_transfer_learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aRa-6AoZhnURRXG-1GATTo-LfI8_XRs2
"""

from google.colab import drive
drive.mount('/content/drive')

pip install patool

import patoolib
patoolib.extract_archive("/content/drive/MyDrive/genres_images.rar", outdir="/content")

"""
Authors : Rayane KADEM
In This program we use transfer learning with a pretrained vgg16model CNN model. We set the last 4
layers of the convolutional block to be re-trained, and we add 3 fully connected layers for the 
classifciation block. Vgg16 was trained previously on the well known ImageNet dataset. 
The presented architecture is inspired from a work of transfer learning for the task of writer 
identification with handwritten documents and yielded very promessing results. Which led us to test it
on the matter at hand.
"""

# Importing the required libraries
import tensorflow as tf
import numpy as np
from tensorflow.keras.models import Model
from fetch_training_dataset import fetch_spectogram_dataset
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import itertools
#import argparse
import keras
from keras.layers import Flatten, Dense, Dropout, Conv2D, Activation ,MaxPooling2D, Flatten
from tensorflow.keras.models import Sequential
from tensorflow.keras.applications.vgg16 import VGG16
from keras.callbacks import EarlyStopping
from fetch_training_dataset import prep_data_images

data = prep_data_images()
data.prep_data("/content/genres_images",(224,124))

classes = ["rock","hiphop","country","jazz","metal","blues","reggae","disco","Classical","pop"]

# Defining the black box model
class CNNModel:
    def __init__(self):
        self.model = None
        self.model_name = "transfer_learning_vgg16_model_adam_crossEn"
        self.model_path = "/content/drive/MyDrive/Mymodels_result" + self.model_name +"/"+ self.model_name + ".h5"
        self.model_weights_path = "/content/drive/MyDrive/Mymodels_result" + self.model_name +"/"+  self.model_name + "_weights.h5"
        self.model_history_path_acc = "/content/drive/MyDrive/Mymodels_result" + self.model_name +"/"+ self.model_name + "_history_acc.png"
        self.model_history_path_loss = "/content/drive/MyDrive/Mymodels_result" + self.model_name +"/"+ self.model_name + "_history_loss.png"
        
        self.model_history = None
    
    def build_model(self):
        """
        This function is used to create the black box model :
        """
        # Defining the input layer
        
        model = Sequential()

        vggmodel=VGG16(include_top=False, weights='imagenet', input_tensor=None, input_shape=(124,224 , 3), pooling=None)
        
        # Take all weights of imagenet dataset except for last four layers
        for layer in vggmodel.layers[:-8]: 
            layer.trainable = False 

        x = vggmodel.output
        x = Flatten()(x)

        x = Dense(512, activation="relu")(x)
        x = Dropout(0.2)(x)
        x = Dense(128, activation="elu")(x)
        predictions = Dense(10, activation="softmax")(x)

        # creating the final model 
        model = Model( vggmodel.input, predictions)

        # Compiling the model
        self.model = model
        
        self.model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.00001), loss = "categorical_crossentropy", metrics=['accuracy'])
        return vggmodel, x
    def train_model(self,data, epochs=10):
        """
        This function is used to train the black box model :
        """
        # Training the model
        self.model_history = self.model.fit(data.Xtrain,data.ytrain, epochs=epochs,validation_data=(data.Xtest,data.ytest), shuffle=True)
        
    def save_model(self):
        """
        This function is used to save the black box model :
        """
        # Save the model
        self.model.save(self.model_path)
        
    def load_model(self):
        """
        This function is used to load the black box model :
        """
        # Load the model
        self.model = tf.keras.models.load_model(self.model_path)
        
    def save_model_weights(self):
        """
        This function is used to save the weights of the black box model :
        """
        # Save the weights
        self.model.save_weights(self.model_weights_path)
    

    def evaluate_model(self, Xtest,ytest):
        """
        This function is used to evaluate the black box model :
        """
        # Evaluate the model
        test_loss, test_acc = self.model.evaluate(Xtest,ytest)
        print("Test loss: ", test_loss)
        print("Test accuracy: ", test_acc)
    
    def plot_model_history(self):
        """
        This function is used to plot the model history :
        """
        #define variables
        loss = self.model_history.history['loss']
        val_loss = self.model_history.history['val_loss']
        accuracy = self.model_history.history['accuracy']
        val_accuracy = self.model_history.history['val_accuracy']
        epochs = range(1, len(loss) + 1)
        # Plot the model history
        plt.figure()
        plt.plot(epochs, accuracy, label='Training accuracy')
        plt.plot(epochs, val_accuracy, label='Validation accuracy')
        plt.title('Training and validation accuracy')
        plt.legend()
        plt.savefig(self.model_history_path_acc)
        plt.show()

        plt.figure()
        plt.plot(epochs, loss, label='Training loss')
        plt.plot(epochs, val_loss, label='Validation loss')
        plt.title('Training and validation loss')
        plt.legend()
        plt.savefig(self.model_history_path_loss)
        plt.show()
        
    def predict_class(self, spectrogram_image):
        """
        This function is used to predict the class of the spectrogram image :
        """
        # Predict the class
        prediction = self.model.predict(spectrogram_image)
        return np.argmax(prediction)

    def predict_classes(self, spectrogram_images):
        """
        This function is used to predict the classes of the spectrogram images :
        """
        # Predict the classes
        predictions = self.model.predict(spectrogram_images)
        return np.argmax(predictions, axis=1)

    
    def plot_confusion_matrix(self, Xtest,ytest, classes=None):
        """
        This function is used to plot the confusion matrix :
        """
        # Predict the classes
        predictions = self.predict_classes(Xtest)
        # Plot the confusion matrix
        y_parse = np.argmax(ytest, axis=1)
        cm = confusion_matrix(y_parse, predictions)
        #if classes is None:
        #    classes = test_generator.class_indices.keys()
        plt.figure()
        plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)
        plt.title("Confusion matrix")
        plt.colorbar()
        tick_marks = np.arange(10)
        plt.xticks(tick_marks,classes,  rotation=45)
        plt.yticks(tick_marks,classes)
        fmt = 'd'
        thresh = cm.max() / 2.
        for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
            plt.text(j, i, format(cm[i, j], fmt), horizontalalignment="center", color="white" if cm[i, j] > thresh else "black")
        plt.ylabel('True label')
        plt.xlabel('Predicted label')
        plt.tight_layout()
        plt.savefig("/content/drive/MyDrive/Mymodels_result"+ self.model_name +"/"+"confusion_matrix.png")
        plt.show()
        acc = np.diag(cm).sum() /cm.sum()
        print("acc",acc)



for i in range(1):
    
    # Fetch the training and test dataset
    
    # Create the  model
    model = CNNModel()
    
    # Build the  model
    vggmodel, model_features=model.build_model()
    # Train the  model
    model.train_model(data, epochs=34)
    
    # Save the  model
    model.save_model()

    # Evaluate  model
    model.evaluate_model(data.Xtest,data.ytest)

    # Plot the model history
    model.plot_model_history()
    
    # Plot the confusion matrix
    model.plot_confusion_matrix(data.Xtest,data.ytest)

black_box_model.plot_confusion_matrix(data.Xtest,data.ytest)

"""## SVM with CNN features"""

extractor = Model( vggmodel.input,model_features)

xapp = extractor.predict(data.Xtrain) # training CNN features vector
xtest = extractor.predict(data.Xtest) # testing CNN features vector

from sklearn import preprocessing 
""" MIN MAX SCALER """
min_max_scaler = preprocessing.MinMaxScaler(feature_range =(0, 1)) 
# Scaled feature 
xapp_n = min_max_scaler.fit_transform(xapp)
xtest_n = min_max_scaler.fit_transform(xtest)

from sklearn import svm
from sklearn.metrics import accuracy_score

import pandas as pd
yT  = np.argwhere(data.ytrain)
yTr = yT[:,1] 
yT  = np.argwhere(data.ytest)
yTs = yT[:,1]

C2 = np.array([100,200,500,1000,2015])
C1 = np.arange(1, 40,2)
C=np.append(C1,C2)
#C = np.append([1],C,axis=0)  #21 values
m=len(C)
G1 = np.array([0.001,0.01,0.1,0.5,1])  #
G2 = np.arange(2, 8, 2)  
G=np.append(G1,G2) 

n=len(G)
#G = G.astype(int)
#tmbr_all = np.zeros((33,11))
i=0
j=0
tmbr_all = np.zeros((n,m))
for C_value in C:
    for g_value in G:
    
        clf = svm.SVC(kernel='rbf', C=C_value, gamma=g_value)
        clf.fit(xapp_n, yTr)
        predicted = clf.predict(xtest_n)
        tmbr = accuracy_score(predicted,yTs)
        print(tmbr*100, C_value, g_value)
        tmbr_all[i,j] = tmbr
        i=i+1
    i=0
    j=j+1
#best_value(tmbr_all,G,C)

tmbr_all.max()

"""SVM with CNN features did not very much serve our purpose and gave similar values to the fully connected classification block of our CNN model. Thus we might use it again with other features extraction methods. """